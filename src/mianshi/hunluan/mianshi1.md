# 面试题总结

## 1.事件循环理解
事件循环（Event Loop）是 JavaScript 异步编程实现的核心机制之一。它负责在同步任务执行完毕后，从任务队列中取出异步任务并执行。

JavaScript 代码分为同步任务和异步任务两种类型。同步任务直接按顺序执行；异步任务会先被放入任务队列中等待，直到 Event Loop 取出它们并执行。

在实现中，Event Loop 维护了一个任务队列，包含两类任务：宏任务和微任务。宏任务包括 I/O 回调、定时器回调等，而微任务主要是 Promise 和 async/await 生成的任务。

在执行任务时，首先会执行当前栈内的所有任务，然后查看是否有微任务，如果有则立即执行微任务，直到全部微任务都完成，再执行宏任务。这里需要注意，微任务的优先级高于宏任务。

当执行宏任务时，如果其中创建了新的任务，则将这些任务加入到任务队列中等待执行。

总体来说，JavaScript 异步编程离不开事件循环机制的支持，了解事件循环原理可以帮助开发者更好地理解和利用 JavaScript 的异步特性。

————————————————

## 37.客端怎么处理JS事件失效的问题
当客户端遇到JavaScript事件失效的问题时，可以尝试以下解决方法：

1. 检查代码错误：检查JavaScript代码中是否存在错误，如语法错误、逻辑错误等。使用开发者工具（如浏览器的控制台）查看是否有报错信息，并逐个排查和修复错误。
2. 确保元素存在：确保事件绑定的元素存在于DOM中。如果元素是动态生成的，需要确保在绑定事件之前元素已经被正确创建和插入到DOM中。
3. 绑定事件顺序：确认事件绑定的顺序是否正确。某些情况下，先后绑定多个事件可能会影响它们的执行顺序，导致事件失效。可以按照需要调整事件绑定的顺序，或合理使用事件委托以确保事件能够正常执行。
4. 避免重复绑定：确保事件只绑定一次，避免重复绑定相同的事件。多次绑定同一事件可能会导致事件触发多次或执行顺序混乱，从而产生问题。
5. 检查事件类型和选择器：确认事件类型和事件处理函数的选择器是否匹配。例如，如果绑定了点击事件，但用户实际操作的是键盘回车键，那么事件不会触发。还需确保选择器与目标元素的结构和属性匹配。
6. 确认事件绑定时机：部分情况下，可能是由于在合适的时机绑定事件。确保在DOM完全加载（如DOMContentLoaded或window.onload事件）之后再绑定事件，以避免因为元素尚未加载完成而导致事件失效。
7. 考虑事件代理：对于动态生成的元素或大量重复元素，可以使用事件代理（Event Delegation）的方式来绑定事件。通过将事件绑定在它们的祖先元素上，利用事件冒泡原理捕获并处理目标元素的事件，从而简化事件绑定和改善性能。
8. 测试兼容性：不同浏览器对某些事件的支持和实现可能存在差异，可能导致事件失效。可进行跨浏览器测试，查看是否有兼容性问题，并根据需要进行针对性的处理和修复。
    ————————————————
## 40.如果有一个非常大的react页面 我想优先渲染某一部分该怎么做
如果你有一个非常大的React页面，并且希望优先加载和渲染其中的某一部分，可以考虑以下几种方法：
1. 组件拆分：将整个页面拆分成多个小组件，按照页面的逻辑结构划分。然后，确保优先加载和渲染需要优先显示的部分所对应的组件，而将其他部分作为延迟加载的组件。这样，用户首先能够看到并与重要内容进行交互，而不必等待整个页面全部加载完成。
2. Code Splitting（代码分割）：使用Webpack或者其他打包工具支持的Code Splitting功能，将页面中的代码拆分成多个独立的块（chunks）。可以通过动态导入（dynamic import）、React.lazy()和Suspense组件等技术，根据需要按需加载特定模块，并在加载时显示占位符。这样可以实现在网页加载过程中逐步渲染各个模块的效果，优先展示目标部分。
3. Virtualized rendering（虚拟化渲染）：对于大量数据列表，可以使用虚拟化渲染技术，如react-virtualized、react-window或react-lazy-load等库，只渲染可视区域内的部分，延迟加载其余部分。这种方式可以减少初始渲染的负载，并提高性能和用户体验。
4. 懒加载图片：对于页面中的图片资源，可以使用懒加载（lazy loading）技术。当用户滚动到图片所在的位置时，再进行真正的加载和显示，而不是一次性加载所有的图片。使用像LazyLoad这样的React库可以方便地实现图片懒加载。

## 41.浏览器渲染机制简要解析

浏览器渲染机制是指浏览器在接收和处理HTML、CSS和JavaScript等资源时，将这些资源转化为可视化的网页页面的过程。以下是浏览器渲染的简要解析：

1. 浏览器渲染流程：

   - 构建DOM树：浏览器将接收到的HTML文档解析成DOM树，表示文档的结构和层次关系。
   - 构建CSSOM树：解析CSS文件并构建CSSOM树，表示样式规则的层次关系和定义。
     将DOM和CSSOM合并成Render树：将DOM树和CSSOM树合并，创建Render树，该树包含了需要被渲染的元素和对应的样式信息。
   - 布局（Layout）：计算各个元素在页面中的位置和大小，形成布局树（Box Model）。
   - 绘制（Paint）：根据布局树进行具体像素的绘制，在屏幕上展示出来。
   - 合成（Composition）：将不同图层的绘制结果进行合成，创建最终的页面显示。

2. 优化页面渲染的技巧：

   - 减少重绘和重排：尽量避免频繁修改影响页面布局的样式属性，因为每次修改会导致浏览器计算布局并重新绘制，影响性能。

   - 使用合适的CSS选择器：避免使用过于复杂的CSS选择器，这可能导致解析和匹配过程耗时，建议使用高效的选择器。

   - 虚拟列表（Virtualized List）：对于大型列表或表格，可以只渲染可见区域内的元素，动态加载和卸载列表项，减少页面渲染的工作量。

   - 懒加载（Lazy Loading）：延迟加载不必要的资源，如图片、视频等，在需要时再进行加载，提高初始加载速度和减轻服务器负载。

   - 分割任务（Chunking）：将大型任务分割成多个小任务处理，利用浏览器的异步执行机制，确保优先渲染重要的部分。

通过以上优化技巧，我们可以在特定场景下优先渲染某一部分内容，提高页面加载速度和用户体验。需要根据具体情况进行优化，并结合性能测试和监控来评估效果

## 42.HTTPS如何实现安全通信，建立通信过程

HTTPS（Hypertext Transfer Protocol Secure）是一种通过SSL/TLS加密保护的HTTP协议，用于在网络上进行安全的通信。以下是HTTPS实现安全通信并建立通信过程的步骤：

1. 客户端发送请求：
- 当客户端发起HTTPS请求时，在URL中使用"https://"前缀标识。
- 客户端向服务器发送一个具有保密性要求的连接请求。
2. 服务器证书：
- 服务器接收到客户端请求后，会将自己的数字证书发送给客户端。
- 证书包含服务器公钥、证书颁发机构（Certification Authority）签名等信息。
3. 客户端验证证书：
- 客户端收到服务器证书后，会验证其有效性。
- 客户端检查证书是否由受信任的证书颁发机构签署，确认证书的真实性和合法性。
4. 生成共享密钥：
- 客户端使用服务器的公钥对生成一个随机的对称密钥（称为会话密钥或对称密钥）。
- 这个对称密钥用于后续的数据加密和解密。
5. 加密通信：
- 客户端使用服务器的公钥对会话密钥进行加密，并发送给服务器。
- 服务器使用自己的私钥解密客户端发来的会话密钥。
6. 数据传输：
- 客户端和服务器使用会话密钥对数据进行加密和解密。
- 所有通过HTTPS通信的数据都经过加密处理，保证数据在传输过程中的机密性。
通过以上步骤，HTTPS实现了安全通信和数据加密保护，确保了客户端和服务器之间的数据传输的安全性和完整性。这样可以有效防止网络拦截、窃听和篡改等安全威胁。


## 47.前端跨域有什么好的解决方案
前端跨域是指在浏览器环境下，当一个网页的执行环境（源）与该网页所请求资源的服务器域名、端口或协议不一致时，会出现跨域问题。为了解决前端跨域问题，可以采用以下几种常见的解决方案：

1. JSONP（JSON with Padding）：利用 标签的可跨域特性，通过动态创建 标签并指定请求的 URL，服务器返回经过函数封装的 JSON 数据，实现跨域数据获取。
2. CORS（Cross-Origin Resource Sharing）：在服务端设置响应头信息，允许特定域名的请求进行跨域访问。需要注意，在浏览器环境下，只有针对 XMLHttpRequest 或 Fetch 发起的非简单请求（如跨域的 POST、PUT、DELETE 请求等）才会触发预检请求（OPTIONS），来验证是否允许跨域访问。
3. 代理服务器：将前端的 HTTP 请求发送到同源的后端服务器，由后端服务器转发请求到目标服务器并返回响应。前端需要配置代理服务器的地址和路径映射关系，使得浏览器认为请求是同源的，从而避免跨域问题。
4. WebSocket：使用 WebSocket 协议进行通信，该协议可以在 JavaScript 中直接建立持久化的双向通信，不受同源策略限制。
5. Nginx 反向代理：通过在 Nginx 配置文件中添加反向代理规则，将前端请求转发到目标服务器，并在配置中设置跨域响应头信息，实现跨域访问。
6. postMessage API：使用 HTML5 提供的 postMessage API，在不同窗口或标签间进行安全跨域通信。
————————————————

## 51.什么是NGINX负载均衡，常用的NGINX负载均衡算法有哪些?
NGINX负载均衡是一种将网络流量平衡地分发到多个服务器上的技术，以实现高可用性、提高性能和扩展性。它可以根据预定的算法和规则将传入的请求动态地转发给后端的多台服务器进行处理。

常用的NGINX负载均衡算法包括：
————————————————
1. 轮询（Round Robin）：将请求按照顺序轮流分发给每台服务器，实现简单公平的负载均衡。
2. 加权轮询（Weighted Round Robin）：为每台服务器分配一个权重值，根据权重不同来决定分发请求的比例，使得处理能力较强的服务器能够处理更多的请求。
3. IP哈希（IP Hash）：根据客户端的IP地址进行哈希计算，确定将该请求发送给固定的一台服务器，这样可以保证相同IP的请求 always land on the same server。
4. 最少连接（Least Connections）：将新的请求发送到当前连接数最少的服务器，以实现负载均衡和避免因某些请求需要更长时间导致服务器负载过高的问题。
5. 动态负载（Dynamic Load）：通过监控服务器的负载情况，动态地调整权重或者添加/移除服务器，以确保系统在任何情况下都能够保持平衡。
## 53.说一下DOM0、DOM2、DOM3事件处理的区别是什么？
- DOM0事件处理：是最早出现的一种事件处理方式，通过在DOM节点上直接指定事件处理函数来实现。
- DOM2事件处理：DOM2级事件定义了两种方法，addEventListener和removeEventListener，它们可以动态地添加和移除事件处理函数。DOM2事件处理可以添加多个事件处理函数，它们按照添加的顺序依次执行
- DOM3事件处理：DOM3级事件增加了更多的事件类型，例如鼠标滚轮事件、键盘按键事件、文本输入事件等。除此之外，DOM3事件处理还增加了更多的方法，例如preventDefault()、stopPropagation()、stopImmediatePropagation()等，这些方法可以更加精确地控制事件的传播和处理。

## 54.说说html和css渲染的过程是什么
HTML和CSS渲染的过程一般分为三个阶段：解析、渲染和合成。下面是具体的流程：

- 解析HTML：浏览器首先会解析HTML，生成一颗DOM树。DOM树是由一些个体（HTML标签、CSS样式）构成的树形结构，表示整个页面的结构和层级关系。

- 解析CSS：浏览器接着解析CSS文件，生成一份CSSOM树。CSSOM树也是由一些个体（CSS样式）构成的树形结构，表示整个页面的样式信息。

- 合成：在完成DOM树和CSSOM树的解析后，浏览器就可以开始将它们合成为一颗渲染树（Render Tree），这个过程就是合成。渲染树只包含渲染网页所必须的节点，例如可见的节点，所有的CSS信息和计算后的样式属性，不可见的节点和一些不需要渲染的节点就不在渲染树中。

- 布局：渲染树生成后，浏览器会根据每个节点的内容、样式等信息计算其在页面中的位置和大小，这个阶段称为布局（Layout）。

- 绘制：最后是绘制（Painting）阶段，浏览器遍历渲染树，并依据树中节点的几何信息将所有的节点绘制出来，呈现在屏幕上。

需要注意的是，HTML和CSS渲染的过程是一个复杂的过程，可以受到很多因素的影响，并且在实际渲染中会涉及到很多细节和优化，了解渲染的基本流程可以帮助我们更好的理解页面渲染的过程，从而更好地进行前端的开发和调试。

## 56.什么是FOUC? 如何避免？
FOUC是指页面在加载时，由于CSS文件的加载顺序导致页面的样式先后变化，从而出现页面闪烁的现象。FOUC的全称是“Flash of Unstyled Content”。

要避免FOUC，我们可以采取以下几种方式：

- 将CSS样式表放在HTML文档头部，这样浏览器加载HTML时就可以同时加载CSS文件，避免了样式变化的闪烁。
- 使用媒体查询，对不同的设备采取不同的CSS样式，以避免因页面元素的尺寸改变导致的样式变化。
- 使用JavaScript将CSS样式表动态地插入到页面中，可以避免页面的样式变化。
- 使用CSS样式表中的特定属性，如visibility: hidden或者opacity: 0，避免在页面加载时元素的显示
- 在HTML标签上加上style="display:none"的方式，避免页面的样式变化。在JS中，我们可以使用window.onload事件，在页面元素加载完毕后再显示页面。


## 60.你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢
SPA应用就是一个web应用，可理解为：是一种只需要将单个页面加载到服务器之中的web应用程序。当浏览器向服务器发出第一个请求时，服务器会返回一个index.html文件，它所需的js，css等会在显示时统一加载，部分页面需要时加载。

优点：1：良好的交互式体验 2：良好的前后端分离模式（MVVM），减轻服务端压力。3：共用同一套后端程序代码，不用修改就可用于web界面，手机和平板等客户端设备

缺点：1.不利于SEO优化。2.不能使用浏览器自带的前进和后退功能3…首屏加载过慢。

**实现一个SPA：**

1. 监听地址栏中hash变化驱动界面变化
2. 用pushsate记录浏览器的历史，驱动界面发送变化

## 61.SPA首屏加载速度慢怎么解决
**加载慢的原因**
1. 网络延时问题
2. 资源文件是否体积过大
3. 资源是否重复发送请求加载
4. 加载脚本的时候，渲染内容堵塞

**解决优化方案**

1. 减小入口文件体积
2. 静态资源本地缓存
3. 第三方插件按需加载或者使用CDN引用
4. 图片资源压缩
5. 抽离公共组件避免重复打包
6. 开启GZip压缩
7. 使用SSR

## 62.说说箭头函数和普通函数的区别
1. 语法上的区别：箭头函数使用箭头符号（=>）来定义函数，而普通函数使用 function 关键字定义。
2. this 指向不同：箭头函数没有自己的 this，它的 this 指向的是定义时的作用域中的 this；而普通函数的 this 指向的是调用时的上下文对象。
3. 箭头函数没有 arguments 对象，因此不能直接访问函数参数；而普通函数可以使用 arguments 对象来访问函数参数。
4. 箭头函数不能作为构造函数使用，因为它没有自己的 this 对象；而普通函数可以通过 new 关键字来作为构造函数使用，生成一个新的实例对象。
   

总的来说，箭头函数相对于普通函数来说更加简洁，但是在某些场景下可能会有一些限制，需要根据实际情况进行选择。

## 63.如何快速的让一个打乱一个数组的顺序，比如 var arr = [1,2,3,4,5,6,7,8,9,10
1.时间复杂度O（n^2）

2.时间复杂度O（n）

原理：主要是将数组里的索引值随机打乱，然后将当前的索引值与随机变化之后的索引值互换。

​	(1).首先遍历的开始是从最大的索引开始，然后逐次递减；

​	(2).然后选取一个随机值randomIndex，这个随机值的产生是在0-len（即数组的长度）之间产生，由于这个值不能为len（因为数组的索引是从0开始的），只能为len-1，故只能向下取整Math.floor；

(3).取到随机值之后，将这个随机值对应的数组值即arr[randomIndex]赋值给当前遍历的i对应的数组值即arr[i]；

3.sort 是对数组进行排序，每次从数组里面挑选两个数 进行运算。

- 如果传入的参数是0，两个数位置不变
- 如果参数小于0，就交换位置
- 如果参数大于0，就不交换位置

我们利用 Math.random-0.5，这个运算的结果要么是大于0,要么是小于0.这样要么交换位置，要么不交换位置。当然大于或者小于0是随即出现的。所以数组就被随即排序了。


## 65.说说Promise和async/await的区别是？

Promise是原生的解决异步代码的对象，promise中有三个状态分别是pedding等待中、rejected失败、resolve成功，根据三个状态可以拿到我们的异步任务执行的结果，其中通过链式的.then回调方法中操作。

Async/await是基于promise封装的解决异步编程带来的回调地狱的终极方案，当我们呢在有很多的异步任务相互嵌套执行时就会出现，无限的层级嵌套，代码相当不清晰，async和await的出现解决了这个问题。


## 67.null，undefined 的区别
他们的数据类型不一样：null的数据类型为object、而undefined为undefined

他们相等于但是不恒等于，null定义的数据表示数据为空

总结来说，undefined 表示的是变量未定义或未初始化，而 null 表示变量的值为空。 需要注意的是，在条件判断时，null==undefined 返回 true，但它们的数据类型不同，所以 null === undefined 返回 false。


## 69. 网站性能优化的方案都有哪些？

1. 尽量减少HTTP请求次数
2. 延迟加载内容
3. 使用离线缓存
4. CSS、JS放置正确位置
5. 静态资源压缩
6. 静态资源使用多个域名
7. 静态资源使用cdn存储
8. 预加载
9. DOM操作优化
10. 优化算法






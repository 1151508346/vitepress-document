# 面试题总结

## 1.事件循环理解
事件循环（Event Loop）是 JavaScript 异步编程实现的核心机制之一。它负责在同步任务执行完毕后，从任务队列中取出异步任务并执行。

JavaScript 代码分为同步任务和异步任务两种类型。同步任务直接按顺序执行；异步任务会先被放入任务队列中等待，直到 Event Loop 取出它们并执行。

在实现中，Event Loop 维护了一个任务队列，包含两类任务：宏任务和微任务。宏任务包括 I/O 回调、定时器回调等，而微任务主要是 Promise 和 async/await 生成的任务。

在执行任务时，首先会执行当前栈内的所有任务，然后查看是否有微任务，如果有则立即执行微任务，直到全部微任务都完成，再执行宏任务。这里需要注意，微任务的优先级高于宏任务。

当执行宏任务时，如果其中创建了新的任务，则将这些任务加入到任务队列中等待执行。

总体来说，JavaScript 异步编程离不开事件循环机制的支持，了解事件循环原理可以帮助开发者更好地理解和利用 JavaScript 的异步特性。

————————————————

## 35.怎么优化H5让它可以在300ms以内打开？

1. 减少页面资源大小：通过压缩和合并CSS和JavaScript文件，以及对图片进行优化和懒加载，减小页面资源的总体大小。
2. 延迟加载非关键资源：将非关键资源（如广告、统计代码等）延迟加载，以保证页面首次打开时能够快速呈现内容。
3. 使用CDN加速：将静态文件（例如CSS、JavaScript和图片）部署到全球分布式的内容分发网络（CDN）上，可以加快文件加载速度。
4. 使用缓存：通过设置合适的缓存策略，浏览器可以缓存页面的静态资源，再次访问时可以直接从缓存中获取，提高页面加载速度。
5. 减少HTTP请求：减少页面上的HTTP请求次数，合并CSS和JavaScript文件，并尽量使用雪碧图或SVG精灵图来减少图片请求次数。
6. 使用异步加载：将不影响页面渲染的JavaScript文件采用异步加载方式，以防止其阻塞页面的加载。
   优化服务器响应时间：确保服务器响应时间尽可能短，可以通过优化数据库查询、减少不必要的计算和IO操作等方式来提高服务器性能。
7. 前端性能优化：使用有效的HTML结构、CSS样式和JavaScript代码来减少页面渲染时间，避免不必要的布局重绘和重排。
8. 使用预加载技术：可以通过使用标签预加载关键资源，以提前获取页面所需的资源，加快页面打开速度。
   

## 37.客端怎么处理JS事件失效的问题
当客户端遇到JavaScript事件失效的问题时，可以尝试以下解决方法：

1. 检查代码错误：检查JavaScript代码中是否存在错误，如语法错误、逻辑错误等。使用开发者工具（如浏览器的控制台）查看是否有报错信息，并逐个排查和修复错误。
2. 确保元素存在：确保事件绑定的元素存在于DOM中。如果元素是动态生成的，需要确保在绑定事件之前元素已经被正确创建和插入到DOM中。
3. 绑定事件顺序：确认事件绑定的顺序是否正确。某些情况下，先后绑定多个事件可能会影响它们的执行顺序，导致事件失效。可以按照需要调整事件绑定的顺序，或合理使用事件委托以确保事件能够正常执行。
4. 避免重复绑定：确保事件只绑定一次，避免重复绑定相同的事件。多次绑定同一事件可能会导致事件触发多次或执行顺序混乱，从而产生问题。
5. 检查事件类型和选择器：确认事件类型和事件处理函数的选择器是否匹配。例如，如果绑定了点击事件，但用户实际操作的是键盘回车键，那么事件不会触发。还需确保选择器与目标元素的结构和属性匹配。
6. 确认事件绑定时机：部分情况下，可能是由于在合适的时机绑定事件。确保在DOM完全加载（如DOMContentLoaded或window.onload事件）之后再绑定事件，以避免因为元素尚未加载完成而导致事件失效。
7. 考虑事件代理：对于动态生成的元素或大量重复元素，可以使用事件代理（Event Delegation）的方式来绑定事件。通过将事件绑定在它们的祖先元素上，利用事件冒泡原理捕获并处理目标元素的事件，从而简化事件绑定和改善性能。
8. 测试兼容性：不同浏览器对某些事件的支持和实现可能存在差异，可能导致事件失效。可进行跨浏览器测试，查看是否有兼容性问题，并根据需要进行针对性的处理和修复。

## 39.Node服务怎么去定位CPU占用暴涨的情况?怎么去定位内存泄露?
定位CPU占用暴涨和内存泄露是Node服务性能调优的关键任务。下面是一些常用的方法来定位这些问题：

1. 定位CPU占用暴涨：
    - 使用操作系统自带的工具，如Linux的top命令或Windows的Task Manager，可以查看进程的CPU占用情况，并确定哪个进程消耗了大量的CPU资源。
    - 使用工具进行性能分析，例如Node.js自带的profiler（v8-profiler）或第三方工具如Chrome开发者工具（Chrome DevTools）的CPU Profiler，可以捕获CPU执行时间较长的函数或代码块，从而确定具体是哪部分代码造成了CPU占用暴涨。

2. 定位内存泄露：
- 使用Node.js自带的内存分析工具，如heapdump模块，可以生成堆快照（heap snapshot），并通过分析快照中的对象引用关系，找到可能导致内存泄露的对象。
- 使用第三方工具如Chrome开发者工具的Heap Profiler，在浏览器中查看和分析内存使用情况，包括内存泄露的对象可视化
- 监测Node进程的内存使用情况，例如使用process.memoryUsage()方法获取内存的详细信息，并跟踪内存的变化，特别注意逐渐增长的趋势，可以帮助发现内存泄露问题。

在定位问题后，可以根据具体情况采取相应的优化策略和调整：

- 对于CPU占用高的情况，可以考虑优化算法、减少不必要的计算、并发控制等方式来降低CPU负载。
- 对于内存泄露问题，可以检查代码中的对象引用是否正确释放，尤其是事件监听、定时器、循环引用等地方可能造成的泄露。使用缓存或连接池时，也需要注意及时释放资源。

## 40.如果有一个非常大的react页面 我想优先渲染某一部分该怎么做
如果你有一个非常大的React页面，并且希望优先加载和渲染其中的某一部分，可以考虑以下几种方法：
1. 组件拆分：将整个页面拆分成多个小组件，按照页面的逻辑结构划分。然后，确保优先加载和渲染需要优先显示的部分所对应的组件，而将其他部分作为延迟加载的组件。这样，用户首先能够看到并与重要内容进行交互，而不必等待整个页面全部加载完成。
2. Code Splitting（代码分割）：使用Webpack或者其他打包工具支持的Code Splitting功能，将页面中的代码拆分成多个独立的块（chunks）。可以通过动态导入（dynamic import）、React.lazy()和Suspense组件等技术，根据需要按需加载特定模块，并在加载时显示占位符。这样可以实现在网页加载过程中逐步渲染各个模块的效果，优先展示目标部分。
3. Virtualized rendering（虚拟化渲染）：对于大量数据列表，可以使用虚拟化渲染技术，如react-virtualized、react-window或react-lazy-load等库，只渲染可视区域内的部分，延迟加载其余部分。这种方式可以减少初始渲染的负载，并提高性能和用户体验。
4. 懒加载图片：对于页面中的图片资源，可以使用懒加载（lazy loading）技术。当用户滚动到图片所在的位置时，再进行真正的加载和显示，而不是一次性加载所有的图片。使用像LazyLoad这样的React库可以方便地实现图片懒加载。

## 41.浏览器渲染机制简要解析

浏览器渲染机制是指浏览器在接收和处理HTML、CSS和JavaScript等资源时，将这些资源转化为可视化的网页页面的过程。以下是浏览器渲染的简要解析：

1. 浏览器渲染流程：

   - 构建DOM树：浏览器将接收到的HTML文档解析成DOM树，表示文档的结构和层次关系。
   - 构建CSSOM树：解析CSS文件并构建CSSOM树，表示样式规则的层次关系和定义。
     将DOM和CSSOM合并成Render树：将DOM树和CSSOM树合并，创建Render树，该树包含了需要被渲染的元素和对应的样式信息。
   - 布局（Layout）：计算各个元素在页面中的位置和大小，形成布局树（Box Model）。
   - 绘制（Paint）：根据布局树进行具体像素的绘制，在屏幕上展示出来。
   - 合成（Composition）：将不同图层的绘制结果进行合成，创建最终的页面显示。

2. 优化页面渲染的技巧：

   - 减少重绘和重排：尽量避免频繁修改影响页面布局的样式属性，因为每次修改会导致浏览器计算布局并重新绘制，影响性能。

   - 使用合适的CSS选择器：避免使用过于复杂的CSS选择器，这可能导致解析和匹配过程耗时，建议使用高效的选择器。

   - 虚拟列表（Virtualized List）：对于大型列表或表格，可以只渲染可见区域内的元素，动态加载和卸载列表项，减少页面渲染的工作量。

   - 懒加载（Lazy Loading）：延迟加载不必要的资源，如图片、视频等，在需要时再进行加载，提高初始加载速度和减轻服务器负载。

   - 分割任务（Chunking）：将大型任务分割成多个小任务处理，利用浏览器的异步执行机制，确保优先渲染重要的部分。

通过以上优化技巧，我们可以在特定场景下优先渲染某一部分内容，提高页面加载速度和用户体验。需要根据具体情况进行优化，并结合性能测试和监控来评估效果

## 42.HTTPS如何实现安全通信，建立通信过程

HTTPS（Hypertext Transfer Protocol Secure）是一种通过SSL/TLS加密保护的HTTP协议，用于在网络上进行安全的通信。以下是HTTPS实现安全通信并建立通信过程的步骤：

1. 客户端发送请求：
- 当客户端发起HTTPS请求时，在URL中使用"https://"前缀标识。
- 客户端向服务器发送一个具有保密性要求的连接请求。
2. 服务器证书：
- 服务器接收到客户端请求后，会将自己的数字证书发送给客户端。
- 证书包含服务器公钥、证书颁发机构（Certification Authority）签名等信息。
3. 客户端验证证书：
- 客户端收到服务器证书后，会验证其有效性。
- 客户端检查证书是否由受信任的证书颁发机构签署，确认证书的真实性和合法性。
4. 生成共享密钥：
- 客户端使用服务器的公钥对生成一个随机的对称密钥（称为会话密钥或对称密钥）。
- 这个对称密钥用于后续的数据加密和解密。
5. 加密通信：
- 客户端使用服务器的公钥对会话密钥进行加密，并发送给服务器。
- 服务器使用自己的私钥解密客户端发来的会话密钥。
6. 数据传输：
- 客户端和服务器使用会话密钥对数据进行加密和解密。
- 所有通过HTTPS通信的数据都经过加密处理，保证数据在传输过程中的机密性。
通过以上步骤，HTTPS实现了安全通信和数据加密保护，确保了客户端和服务器之间的数据传输的安全性和完整性。这样可以有效防止网络拦截、窃听和篡改等安全威胁。


## 47.前端跨域有什么好的解决方案
前端跨域是指在浏览器环境下，当一个网页的执行环境（源）与该网页所请求资源的服务器域名、端口或协议不一致时，会出现跨域问题。为了解决前端跨域问题，可以采用以下几种常见的解决方案：

1. JSONP（JSON with Padding）：利用 标签的可跨域特性，通过动态创建 标签并指定请求的 URL，服务器返回经过函数封装的 JSON 数据，实现跨域数据获取。
2. CORS（Cross-Origin Resource Sharing）：在服务端设置响应头信息，允许特定域名的请求进行跨域访问。需要注意，在浏览器环境下，只有针对 XMLHttpRequest 或 Fetch 发起的非简单请求（如跨域的 POST、PUT、DELETE 请求等）才会触发预检请求（OPTIONS），来验证是否允许跨域访问。
3. 代理服务器：将前端的 HTTP 请求发送到同源的后端服务器，由后端服务器转发请求到目标服务器并返回响应。前端需要配置代理服务器的地址和路径映射关系，使得浏览器认为请求是同源的，从而避免跨域问题。
4. WebSocket：使用 WebSocket 协议进行通信，该协议可以在 JavaScript 中直接建立持久化的双向通信，不受同源策略限制。
5. Nginx 反向代理：通过在 Nginx 配置文件中添加反向代理规则，将前端请求转发到目标服务器，并在配置中设置跨域响应头信息，实现跨域访问。
6. postMessage API：使用 HTML5 提供的 postMessage API，在不同窗口或标签间进行安全跨域通信。
————————————————

## 51.什么是NGINX负载均衡，常用的NGINX负载均衡算法有哪些?
NGINX负载均衡是一种将网络流量平衡地分发到多个服务器上的技术，以实现高可用性、提高性能和扩展性。它可以根据预定的算法和规则将传入的请求动态地转发给后端的多台服务器进行处理。

常用的NGINX负载均衡算法包括：
————————————————
1. 轮询（Round Robin）：将请求按照顺序轮流分发给每台服务器，实现简单公平的负载均衡。
2. 加权轮询（Weighted Round Robin）：为每台服务器分配一个权重值，根据权重不同来决定分发请求的比例，使得处理能力较强的服务器能够处理更多的请求。
3. IP哈希（IP Hash）：根据客户端的IP地址进行哈希计算，确定将该请求发送给固定的一台服务器，这样可以保证相同IP的请求 always land on the same server。
4. 最少连接（Least Connections）：将新的请求发送到当前连接数最少的服务器，以实现负载均衡和避免因某些请求需要更长时间导致服务器负载过高的问题。
5. 动态负载（Dynamic Load）：通过监控服务器的负载情况，动态地调整权重或者添加/移除服务器，以确保系统在任何情况下都能够保持平衡。
## 53.说一下DOM0、DOM2、DOM3事件处理的区别是什么？
- DOM0事件处理：是最早出现的一种事件处理方式，通过在DOM节点上直接指定事件处理函数来实现。
- DOM2事件处理：DOM2级事件定义了两种方法，addEventListener和removeEventListener，它们可以动态地添加和移除事件处理函数。DOM2事件处理可以添加多个事件处理函数，它们按照添加的顺序依次执行
- DOM3事件处理：DOM3级事件增加了更多的事件类型，例如鼠标滚轮事件、键盘按键事件、文本输入事件等。除此之外，DOM3事件处理还增加了更多的方法，例如preventDefault()、stopPropagation()、stopImmediatePropagation()等，这些方法可以更加精确地控制事件的传播和处理。

## 54.说说html和css渲染的过程是什么
HTML和CSS渲染的过程一般分为三个阶段：解析、渲染和合成。下面是具体的流程：

- 解析HTML：浏览器首先会解析HTML，生成一颗DOM树。DOM树是由一些个体（HTML标签、CSS样式）构成的树形结构，表示整个页面的结构和层级关系。

- 解析CSS：浏览器接着解析CSS文件，生成一份CSSOM树。CSSOM树也是由一些个体（CSS样式）构成的树形结构，表示整个页面的样式信息。

- 合成：在完成DOM树和CSSOM树的解析后，浏览器就可以开始将它们合成为一颗渲染树（Render Tree），这个过程就是合成。渲染树只包含渲染网页所必须的节点，例如可见的节点，所有的CSS信息和计算后的样式属性，不可见的节点和一些不需要渲染的节点就不在渲染树中。

- 布局：渲染树生成后，浏览器会根据每个节点的内容、样式等信息计算其在页面中的位置和大小，这个阶段称为布局（Layout）。

- 绘制：最后是绘制（Painting）阶段，浏览器遍历渲染树，并依据树中节点的几何信息将所有的节点绘制出来，呈现在屏幕上。

需要注意的是，HTML和CSS渲染的过程是一个复杂的过程，可以受到很多因素的影响，并且在实际渲染中会涉及到很多细节和优化，了解渲染的基本流程可以帮助我们更好的理解页面渲染的过程，从而更好地进行前端的开发和调试。

## 56.什么是FOUC? 如何避免？
FOUC是指页面在加载时，由于CSS文件的加载顺序导致页面的样式先后变化，从而出现页面闪烁的现象。FOUC的全称是“Flash of Unstyled Content”。

要避免FOUC，我们可以采取以下几种方式：

- 将CSS样式表放在HTML文档头部，这样浏览器加载HTML时就可以同时加载CSS文件，避免了样式变化的闪烁。
- 使用媒体查询，对不同的设备采取不同的CSS样式，以避免因页面元素的尺寸改变导致的样式变化。
- 使用JavaScript将CSS样式表动态地插入到页面中，可以避免页面的样式变化。
- 使用CSS样式表中的特定属性，如visibility: hidden或者opacity: 0，避免在页面加载时元素的显示
- 在HTML标签上加上style="display:none"的方式，避免页面的样式变化。在JS中，我们可以使用window.onload事件，在页面元素加载完毕后再显示页面。


## 60.你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢
SPA应用就是一个web应用，可理解为：是一种只需要将单个页面加载到服务器之中的web应用程序。当浏览器向服务器发出第一个请求时，服务器会返回一个index.html文件，它所需的js，css等会在显示时统一加载，部分页面需要时加载。

优点：1：良好的交互式体验 2：良好的前后端分离模式（MVVM），减轻服务端压力。3：共用同一套后端程序代码，不用修改就可用于web界面，手机和平板等客户端设备

缺点：1.不利于SEO优化。2.不能使用浏览器自带的前进和后退功能3…首屏加载过慢。

**实现一个SPA：**

1. 监听地址栏中hash变化驱动界面变化
2. 用pushsate记录浏览器的历史，驱动界面发送变化

## 61.SPA首屏加载速度慢怎么解决
**加载慢的原因**
1. 网络延时问题
2. 资源文件是否体积过大
3. 资源是否重复发送请求加载
4. 加载脚本的时候，渲染内容堵塞

**解决优化方案**

1. 减小入口文件体积
2. 静态资源本地缓存
3. 第三方插件按需加载或者使用CDN引用
4. 图片资源压缩
5. 抽离公共组件避免重复打包
6. 开启GZip压缩
7. 使用SSR

## 62.说说箭头函数和普通函数的区别
1. 语法上的区别：箭头函数使用箭头符号（=>）来定义函数，而普通函数使用 function 关键字定义。
2. this 指向不同：箭头函数没有自己的 this，它的 this 指向的是定义时的作用域中的 this；而普通函数的 this 指向的是调用时的上下文对象。
3. 箭头函数没有 arguments 对象，因此不能直接访问函数参数；而普通函数可以使用 arguments 对象来访问函数参数。
4. 箭头函数不能作为构造函数使用，因为它没有自己的 this 对象；而普通函数可以通过 new 关键字来作为构造函数使用，生成一个新的实例对象。
   

总的来说，箭头函数相对于普通函数来说更加简洁，但是在某些场景下可能会有一些限制，需要根据实际情况进行选择。

## 63.如何快速的让一个打乱一个数组的顺序，比如 var arr = [1,2,3,4,5,6,7,8,9,10
1.时间复杂度O（n^2）

2.时间复杂度O（n）

原理：主要是将数组里的索引值随机打乱，然后将当前的索引值与随机变化之后的索引值互换。

​	(1).首先遍历的开始是从最大的索引开始，然后逐次递减；

​	(2).然后选取一个随机值randomIndex，这个随机值的产生是在0-len（即数组的长度）之间产生，由于这个值不能为len（因为数组的索引是从0开始的），只能为len-1，故只能向下取整Math.floor；

(3).取到随机值之后，将这个随机值对应的数组值即arr[randomIndex]赋值给当前遍历的i对应的数组值即arr[i]；

3.sort 是对数组进行排序，每次从数组里面挑选两个数 进行运算。

- 如果传入的参数是0，两个数位置不变
- 如果参数小于0，就交换位置
- 如果参数大于0，就不交换位置

我们利用 Math.random-0.5，这个运算的结果要么是大于0,要么是小于0.这样要么交换位置，要么不交换位置。当然大于或者小于0是随即出现的。所以数组就被随即排序了。

## 64.说说什么是严格模式，限制都有哪些
严格模式：当我们在开发项目时，难免会有写的不规范的js代码，当我们开启严格模式后就会提示我们当前的代码有需要改进的地方，比如定义了一个未使用的变量。

定义未使用的变量或方法、严格使用双引号、等等

严格模式的限制：
- 变量必须声明后再使用
- 函数的参数不能有同名属性，否则报错
- 不能使用with语句
- 不能对只读属性赋值，否则报错
- 不能使用前缀 0 表示八进制数，否则报错
- 不能删除不可删除的属性，否则报错
- 不能删除变量delete prop，会报错，只能删除属性delete global- [prop]
- eval不会在它的外层作用域引入变量
- eval和arguments不能被重新赋值
- arguments不会自动反映函数参数的变化
- 不能使用arguments.callee
- 不能使用arguments.caller
- 禁止this指向全局对象
- 不能使用fn.caller和fn.arguments获取函数调用的堆栈
- 增加了保留字（比如protected、static和interface）


## 65.说说Promise和async/await的区别是？

Promise是原生的解决异步代码的对象，promise中有三个状态分别是pedding等待中、rejected失败、resolve成功，根据三个状态可以拿到我们的异步任务执行的结果，其中通过链式的.then回调方法中操作。

Async/await是基于promise封装的解决异步编程带来的回调地狱的终极方案，当我们呢在有很多的异步任务相互嵌套执行时就会出现，无限的层级嵌套，代码相当不清晰，async和await的出现解决了这个问题。


## 67.null，undefined 的区别
他们的数据类型不一样：null的数据类型为object、而undefined为undefined

他们相等于但是不恒等于，null定义的数据表示数据为空

总结来说，undefined 表示的是变量未定义或未初始化，而 null 表示变量的值为空。 需要注意的是，在条件判断时，null==undefined 返回 true，但它们的数据类型不同，所以 null === undefined 返回 false。


## 69. 网站性能优化的方案都有哪些？

1. 尽量减少HTTP请求次数
2. 延迟加载内容
3. 使用离线缓存
4. CSS、JS放置正确位置
5. 静态资源压缩
6. 静态资源使用多个域名
7. 静态资源使用cdn存储
8. 预加载
9. DOM操作优化
10. 优化算法

## 73.let有什么用，有了var为什么还要用let

- var是全局声明，let是块级作用的，只适用于当前代码块
- var变量会发生变量提升，let则不会进行变量提升
- var 会造成重复赋值，循环里的赋值可能会造成变量泄露至全局
- let在一个块级作用只能赋一次值，并进行当前代码块的锁区，就是说当前块只有let声明的这个变量是有用的
- let在一个块级内，只能声明一个一个相同的变量名

## 71.举一些ES6对Array数组类型做的常用升级优化

**优化部分:**
**数组的解构赋值：**
- ES6可以直接以下形式进行变量赋值

- 在声明较多变量时，不需要再写很多let（或var），且映射关系清晰，支持赋默认值。

**扩展运算符:**
ES6新增的扩展运算符（…），可以轻松的实现数组和松散序列（比如集合等）的相互转换，可以取代arguments对象和apply方法，轻松获取未知参数个数情况下的参数集合。（尤其是在ES5即传统js中，arguments不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松实现数组的复制和解构。
**升级部分:**
ES6在Array原型上新增了find（）方法，用于取代传统只能indexOf()查找数组项目的方法，且修复了indexOf查找不到NaN的bug

此外，还新增了copyWithin()、includes()、fill()、flat()等方法，可方便用于数组的查找，补全，和转换等。

## 72.babel是什么，有什么作用?
Babel 是 JavaScript 编译器：他能让开发者在开发过程中，直接使用各类方言（如 TS、Flow、JSX）或新的语法特性，而不需要考虑运行环境，因为Babel可以做到按需转换为低版本支持的代码；Babel内部原理是将 JS 代码转换为 AST，对 AST 应用各种插件进行处理，最终输出编译后的 JS 代码。

**Babel 编译流程:**
1. 解析阶段：Babel 默认使用 @babel/parser将代码转换为AST。解析一般分为两个阶段：词法分析和语法分析。
    1. 词法分析：对输入的字符序列做标记化(tokenization)操作。
    2. 语法分析：处理标记与标记之间的关系，最终形成一颗完整的 AST 结构。
2. 转换阶段：Babel 使用 @babel/traverse 提供的方法对 AST 进行深度优先遍历，调用插件对关注节点的处理函数，按需对 AST 节点进行增删改操作
3. 生成阶段：Babel默认使用 @babel/generator 将上一阶段处理后的 AST 转换为代码字符串。

## 74.举一些ES6对String字符串类型做的常用升级优化?

**优化部分:**
- ES6新增了字符串模板，在拼接大段字符串时，用反引号(`)取代以往的字符串相加的形式,能保留所有空格和换行，使得字符串看起来更加直观、优雅。

ES6模板字符串，允许换行和空格，读写性强
**升级部分:**
ES6在String原型上新增了includes（）方法，用于取代传统只能用indexOf查找包含字符串的方法（indexOf返回-1表示没查到，不如includes（）返回false更明确，语义更清晰），此外还新增了startsWith（）、endsWith（）、padStarts（）、padEnd（）、repeat（）等方法，可更加方便的用于查找、补全字符串
